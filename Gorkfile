require! fs
require! path

option \file, "f", "Build a specific file", "file"

command \build, "Compile egs to JavaScript", #(options, cb)
  async! cb, filename-path <- fs.realpath __filename
  let src-path = path.join(path.dirname(filename-path), "src")
  let lib-path = path.join(path.dirname(filename-path), "lib")
  async! cb, mutable files <- fs.readdir src-path
  
  files := for filter file in files
    not r'prelude\.gs$'.test(file)
  if options.file
    let file-filter = options.file.split ","
    for file in file-filter
      if file not in files
        return cb "Cannot build unknown file: $file"
    files := for filter file in files
      file in file-filter

  if files.length == 0
    return cb("No files to build")
  
  require! gorillascript
  
  let results = {}
  let start-time = new Date().get-time()
  asyncfor next, file in files
    async! cb, text <- fs.read-file path.join(src-path, file), "utf8"
    async! cb, result <- gorillascript.compile text, { extends options, filename: file }
    results[file] := result
    next()
  console.log "Finished building after $(((new Date().get-time() - start-time) / 1000).to-fixed(3)) s"
  asyncfor next, file in files
    async! cb <- fs.write-file path.join(lib-path, file.replace r"\.gs\$", ".js"), results[file].code
    next()
  cb()

command \test, "Run the egs test suite", #(options, cb)
  async! cb, filename-path <- fs.realpath __filename
  let tests-path = path.join(path.dirname(filename-path), "tests")
  async! cb, mutable files <- fs.readdir tests-path
  
  if options.file
    let file-filter = options.file.split ","
    for file in file-filter
      if file not in files
        return cb "Cannot build unknown file: $file"
    files := for filter file in files
      file in file-filter
  else
    files := for filter file in files
      path.extname(file) == ".gs"
  
  if files.length == 0
    return cb("No files to test")
  
  require! assert
  
  let sandbox = {}
  
  let mutable passed-tests = 0
  let add-sandbox(name, func)
    sandbox[name] := #(...args)
      let result = func ...args
      passed-tests += 1
      result

  for k of assert
    add-sandbox k, assert[k]

  let fail = assert.fail
  let success = add-sandbox \success, #->
  let trim(x as String)
    x.trim().replace r"\s+"g, " "
  
  sandbox.eq := #(a, b, msg)
    if a.replace(r"\s"g, "") != b.replace(r"\s"g, "")
      fail "$(JSON.stringify(a) or 'undefined') != $(JSON.stringify(b) or 'undefined')$(if msg then ': ' & msg else '')"
    else
      success()
  
  sandbox.egs := require('./index')
  
  let mutable current-file = null
  let mutable num-failures = 0
  let add-failure(filename, error)!
    num-failures += 1
    if filename
      console.log filename
    if error.description
      console.log "  $(error.description)"
    if error.stack
      console.log error.stack
    else
      console.log String(error)
    if error.source
      console.log error.source
  
  let mutable pending = 0
  let pend() -> pending += 1
  let fulfill() -> pending -= 1
  let wait-for-pending(callback)
    if pending == 0
      callback()
    else
      set-timeout #-> wait-for-pending(callback), 17

  sandbox.test := #(description, fn)!
    try
      fn.test := {
        description
        current-file
      }
      pend()
      fn@ fn, fulfill
    catch e
      try
        e.description := description
        e.source := fn.to-string()
      catch x
        void
      add-failure fn.test.filename, e
  
  let inputs = {}
  asyncfor(0) err <- next, file, i in files
    unless r'\.gs$'i.test(file)
      return next()
    let filename = path.join tests-path, file
    async! next, code <- fs.read-file filename, "utf-8"
    inputs[file] := {code, filename}
    next()

  require! gorillascript
  
  let mutable total-time = 0
  let totals = {}
  asyncfor err <- next, file in files
    if inputs not ownskey file
      return next(new Error("Missing file input for $file"))
    let {code, filename} = inputs[file]

    let basename = path.basename filename
    output "$basename: "
    let mutable failure = false
    let start-time = Date.now()
    current-file := filename
    async err <- gorillascript.eval code.to-string(), { extends options, filename, sandbox, include-globals: true }
    if err?
      output "\n"
      failure := true
      add-failure basename, err
    
    async <- wait-for-pending()
    let end-time = Date.now()
    total-time += end-time - start-time

    output if failure then 'fail' else 'pass'
    output " : "
    output ((end-time - start-time) / 1000_ms).to-fixed(3)
    output " s\n"
    next()

  let message = "passed $passed-tests tests"
  if num-failures == 0
    console.log message
    cb(null)
  else
    console.log "failed $num-failures"
    set-timeout (# -> process.exit(1)), 100
